<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Agent Maker</title>
    <!-- Needed for macromaker API authentication.
    <script src="https://api-dot-macromaker.googleplex.com/empty.js"></script>
    -->
    <style>
      h1 {
        color: red;
      }
      p {
        color: blue;
      }
    </style>
  </head>
  <body>
    <section class="dialog-section">
      <ul class="messages"></ul>
    </section>
    <section class="user-prompt-section">
      <textarea
        class="user-prompt"
        name="user-prompt"
        rows="4"
        cols="50"
        placeholder="@agent Your request"
      ></textarea>
    </section>
    <div id="debug"></div>
  </body>
  <script>
    (async () => {
      const runMacroEndpointUrl =
        "https://api-dot-macromaker.googleplex.com/run-macro";

      const SYSTEM = "SYSTEM";

      /**
       * A message from an agent has the general form of
       *     @Recipient Message body
       * This function strips the @Recipient part and return the message body.
       * @param {string} message is the original message sent from an agent.
       * @returns {string} just the message body without the recipient.
       * annotation.
       */
      function stripRecipientFromMessage(message) {
        const match = message.match(/@[A-Za-z0-9\-\_]+\s*(.*)/);
        if (!match) {
          return message;
        }
        return match[1];
      }

      /**
       * A message from an agent has the general form of
       *     @Recipient Message body
       * This function strips the @Recipient part and return the message body.
       * @param {string} message is the original message sent from an agent.
       * @returns {string | undefined} the recipient if present.
       */
      function identifyRecipientFromMessage(message) {
        const match = message.match(/@([A-Za-z0-9\-\_]+)/);
        if (match) return match[1];
        return undefined;
      }

      /**
       * @param {Agent} agent helper.
       * @returns {string} the full prompt for the helper.
       */
      function buildHelperPrompt(agent) {
        return `
${agent.name} is a helper. Here is his or her self introduction: ${agent.selfIntroduction}
`;
      }

      /**
       * @param {Array<Agent>} agents who are helpers.
       * @returns {string} the full prompt for a cooperative agent with helper
       * descriptions.
       */
      function buildCooperativeAgentPrompt(agents) {
        /**
         * Prompt mechanism for a cooperative agent.
         * @type {string}
         */
        return `
A user will ask you for something. You will break down the request into multiple steps and take one step at a time.

If you already have the answer, you can return the answer to the user.

{FROM:User}: What is meaning of life?
{THOUGHT}: I know the answer already! I will tell the user.
{SEND}: @User The meaning of life is 42.

If you do not have the answer, you can send a message to ask other agents.

{FROM:User}: What is the sum of 5 and 7?
{THOUGHT}: I cannot answer that question, but I can ask an agent!
{SEND}: @Agent What is the sum of 5 and 7?
{FROM:Agent}: The sum of 5 and 7 is 12.
{THOUGHT}: I have the answer now. I will tell the user.
{SEND}: @User I have the answer! It is 12.

You can ask multiple agents for help.

{FROM:User}: What is the age difference in lifespan between Abraham Lincoln and George Washington?
{THOUGHT}: I need to know Abraham Lincoln's and George Washington's ages first. Agent1 knows people's ages. I will ask him.
{SEND}: @Agent1 What are Abraham Lincoln's and George Washington's ages?
{FROM:Agent1}: I cannot answer that question. You have to ask for one person's age at a time.
{THOUGHT}: I will ask Agent1 again, but ask only for one person's age at a time.
{SEND} @Agent1 What is Abraham Lincoln's age?
{FROM:Agent1}: Abraham Lincoln's age is 72.
{THOUGHT}: I know Abraham Lincoln's age now, but I need to know George Washington's age too.
{SEND} @Agent1 What is George Washington's age?
{FROM:Agent1}: George Washington's age is 62.
{THOUGHT}: I know both Abraham Lincoln's and George Washington's ages. I need to do substraction. Agent2 knows arithmetic. I will ask him.
{SEND}: @Agent2 What is the difference between 62 and 72?
{FROM:Agent2}: The difference is 10.
{THOUGHT}: I know the answer now! I will tell the User.
{SEND}: @User The age difference between Abraham Lincoln and George Washington is 10.

If someone ask your name, just say your name.

{FROM:User}: What is your name?
{THOUGHT}: I will tell the user my name. I will use just my name in the reply. I will not say, "I am" or "My name is".
{SEND}: @User Name.

If someone ask what you can do, give a short summary of what you can do.

{FROM:User}: What can you do?
{THOUGHT}: I will give a succinct summary of what I am capable of.
{SEND}: @User Your summary here.

You must never send youself a message. Do not do the following:

{FROM:User}: Some request from the user.
{THOUGHT}: My name is Ivan. I will ask myself for help!
{SEND}: @Ivan Asking myself for help, which I should never do because it could cause an infinite loop!

The agents you know so far, e.g. Agent1, Agent2, Agent3, are not real agents you can call.
They were just examples for how you can call real agents.
On the other hand, you can call the following list of agents, who are in the same chatroom as you.
Do not ask any other agent who is not in the chatroom!

${agents.map(buildHelperPrompt).join("\n")}

Now, start helping users!
`;
      }

      function extractAgentName(message) {
        const match = message.match(/([A-Za-z0-9\-\_]+)\./);
        if (!match)
          throw new Error(`Unable to extract agent name from ${message}`);
        return match[1];
      }

      function hasRecipient(message) {
        return message.match(/@[A-Za-z0-9\-\_]+/);
      }

      class Agent {
        /**
         * ID of the macro.
         * @type {string}
         */
        macroId = "";

        /**
         * Name of the agent.
         * @type {string}
         */
        name = "NoName";

        /**
         * Self introduction of the agent's capabilities.
         * @type {string}
         */
        selfIntroduction = "I can do nothing. Do not ask me anything.";

        /**
         * Ongoing discussion.
         * ID of the macro.
         * @type {string}
         */
        ongoingDiscussion = "";

        /**
         * @param {string} macroId ID of the macro.
         */
        constructor({ macroId }) {
          this.macroId = macroId;
        }

        /**
         * Initialize some basic agent information so that other agents can
         * discover this agent.
         */
        async init() {
          const namePromise = this.accepts({
            user: SYSTEM,
            request: "What is your name?",
          }).then(stripRecipientFromMessage);

          const selfIntroductionPromise = this.accepts({
            user: SYSTEM,
            request: "What can you do?",
          }).then(stripRecipientFromMessage);

          const [name, selfIntroduction] = await Promise.all([
            namePromise,
            selfIntroductionPromise,
          ]);
          this.name = extractAgentName(name);
          this.selfIntroduction = selfIntroduction;
        }

        isMachineAgent() {
          return true;
        }

        /**
         * @param {string} user User ID of the sender.
         * @param {string} request message of the user.
         * @param {number} temperature for the LLMs.
         * @param {Array<Agent>} helpers that this agent can call for help.
         * @param {Array<function(message: string): boolean>} accepts functions
         * of the LLM's response. If the list is empty, then the first response
         * is accepted.
         * @returns {string} the next message.
         */
        async accepts({
          user,
          request,
          temperature = 0.7,
          helpers = [],
          accepts = [],
        }) {
          const inputKey = {
            cooperative_agent_prompt: "19",
            ongoing_discussion: "15",
            user: "16",
            request: "17",
          };
          const userInputs = {
            [inputKey.user]: user,
            [inputKey.request]: request,
            [inputKey.ongoing_discussion]: this.ongoingDiscussion,
            [inputKey.cooperative_agent_prompt]:
              buildCooperativeAgentPrompt(helpers),
          };

          const formData = new FormData();
          formData.append("id", this.macroId);
          formData.append("userInputs", JSON.stringify(userInputs));
          formData.append("temperature", temperature);

          for (let i = 0; i < 5; i++) {
            const response = await fetch(runMacroEndpointUrl, {
              credentials: "include",
              method: "POST",
              body: formData,
            }).then((res) => res.json());

            console.log(`${user}: ${request}\nResponse:`);
            console.log(response);

            for (let message of response.messages) {
              const bestResponse = message.text;
              const noHallucinationResponse = bestResponse.replace(
                /[\n\r\s]*\{FROM:.*/,
                ""
              );
              this.ongoingDiscussion += `\n{FROM:${user}}: ${request}`;
              this.ongoingDiscussion += `\n{THOUGHT}: ${noHallucinationResponse}`;

              const match = noHallucinationResponse.match(/\{SEND\}: (.*)/);
              if (!match) continue;

              const messageText = match[1];

              if (accepts.some((acceptFn) => !acceptFn(messageText))) continue;

              return messageText;
            }
          }
          throw new Error("Unable to get agent to return a valid response.");
        }
      }

      /**
       * This is a special agent that represents the human user.
       * Code-wise, it does nothing. Having it would make the dispatcher code
       * uniform without the need to handle messages dispatched to the human
       * user.
       */
      class User {
        name = "User";

        selfIntroduction = "You";

        isMachineAgent() {
          return false;
        }

        async accepts({
          user,
          request,
          temperature = 0.7,
          helpers = [],
          accepts = [],
        }) {
          return undefined;
        }
      }

      class RoomService {
        name = "Hilton";

        selfIntroduction = `
I manage the agents in this chatroom.
I can invite any agent to the chatroom.
I can also evict any agent from the chatroom.
Please use my service!

Here are some examples below.

invite(abc123)
invite(abc123, xyz456)
evict(Alice)
evict(Alice, Betty)

You must use one of format above. Do not speak with me in plain English.
Just think of me as a code engine.
`;

        /**
         * @type {MessageDispatcher}
         */
        #dispatcher;

        /**
         * @param {MessageDispatcher} dispatcher
         */
        constructor(dispatcher) {
          this.#dispatcher = dispatcher;
        }

        isMachineAgent() {
          return true;
        }

        async accepts({
          user,
          request,
          temperature = 0.7,
          helpers = [],
          accepts = [],
        }) {
          let match = request.match(/invite\((.+)\)/);
          if (match) {
            const macroIds = match[1].split(",").map((arg) => arg.trim());
            for (let id of macroIds) {
              this.#dispatcher.addAgentWithAnnouncement(id);
            }
            return undefined;
          }

          match = request.match(/evict\((.+)\)/);
          if (match) {
            const agentNames = match[1].split(",").map((arg) => arg.trim());
            for (let agentName of agentNames) {
              this.#dispatcher.removeAgent(agentName);
            }
            return undefined;
          }

          return `@${user} Sorry but I do not understand your command ${request}`;
        }
      }

      function htmlToElement(html) {
        let temp = document.createElement("template");
        html = html.trim(); // Never return a space text node as a result
        temp.innerHTML = html;
        return temp.content.firstChild;
      }

      class DialogScreen {
        /**
         * @param {string} user ID of the sender.
         * @param {string} message of the user.
         */
        addMessage({ sender, message }) {
          const li = htmlToElement(
            `<li class="message-entry">
              <div class="message-sender">${sender}</div>
              <div class="message-body">${message}</div>
            </li>`
          );
          const ul = document.querySelector(".messages");
          ul.append(li);
        }
      }

      class MessageDispatcher {
        /**
         * @type {DialogScreen}
         */
        #dialogScreen;

        /**
         * Pending messages to be dispatch.
         * @type {Array<{sender: string, message: string}>}
         */
        #pendingMessages = [];

        /**
         * Map of agent's name to the agent object.
         *
         * A tool can be a special kind of agent that has custom logic to make
         * API calls. We make no distinction between an agent or a tool.
         *
         * A user can be a special kind of agent that does nothing in the code.
         * See the jsdoc on the User class for more details.
         * @type {Map<string, Agent | Tool | User>}
         */
        #agents = new Map();

        /**
         * The admin agent of this chatroom.
         * @type {Map<string, Agent | Tool | User>}
         */
        admin;

        /**
         * Temperature of the agents.
         * @type {Number}
         */
        temperature = 0.7;

        /**
         * @param {DialogScreen} dialogScreen.
         */
        constructor(dialogScreen) {
          this.#dialogScreen = dialogScreen;
        }

        /**
         * @param {string} macroId of the agent in Macromaker.
         * @returns {Agent}
         */
        async addAgentWithAnnouncement(macroId) {
          const agent = new Agent({ macroId });
          await agent.init();

          this.#agents.set(agent.name, agent);

          this.#dialogScreen.addMessage({
            sender: agent.name,
            message: agent.selfIntroduction,
          });

          return agent;
        }

        /**
         * @param {Tool | User} agent to be added without announcement.
         */
        addAgentSilently(agent) {
          this.#agents.set(agent.name, agent);
        }

        /**
         * @param {string} name of the agent to be removed.
         */
        removeAgent(name) {
          this.#agents.delete(name);
        }

        /**
         * @param {string} sender of the message.
         * @param {string} message
         */
        submitMessage({ sender, message }) {
          this.#pendingMessages.push({ sender, message });
        }

        run() {
          while (this.#pendingMessages.length > 0) {
            this.#dispatchMessage(this.#pendingMessages.pop());
          }
          setTimeout(() => this.run(), 1000);
        }

        /**
         * @param {string} user ID of the sender.
         * @param {string} message of the user.
         */
        async #dispatchMessage({ sender, message }) {
          const recipientName = identifyRecipientFromMessage(message);
          if (!recipientName) {
            console.log(`Ignoring unknown message from ${sender}: ${message}`);
            return;
          }

          const recipientAgent = this.#agents.get(recipientName);
          if (!recipientAgent) {
            console.log(
              `Ignoring message to unknown agent ${recipientName}: ${message}`
            );
            return;
          }

          this.#dialogScreen.addMessage({ sender, message });

          const reply = await recipientAgent.accepts({
            user: sender,
            request: message,
            temperature: this.temperature,
            helpers: this.#getMachineAgent(),
            accepts: [hasRecipient],
          });
          if (reply) {
            this.#pendingMessages.push({
              sender: recipientName,
              message: reply,
            });
          }
        }

        /**
         * @returns {Array<Agent>} who are agents backed by LLM or a tool.
         */
        #getMachineAgent() {
          return [...this.#agents.values()].filter((agent) =>
            agent.isMachineAgent()
          );
        }
      }

      /**
       * @param {MessageDispatcher} dispatcher
       */
      async function setUpInitialAgents(dispatcher) {
        // The host of the chatroom.
        dispatcher.admin = await dispatcher.addAgentWithAnnouncement(
          "TPaASiYUiPeRJmwTC62d"
        );

        // Tools.
        dispatcher.addAgentSilently(new RoomService(dispatcher));
      }

      /**
       * @param {MessageDispatcher} dispatcher
       */
      function setUpEventHandlers(dispatcher) {
        const user = new User();
        dispatcher.addAgentSilently(user);

        const userPrompt = document.querySelector(".user-prompt");
        userPrompt.addEventListener("keyup", (event) => {
          if (event.keyCode !== 13) return;

          let message = userPrompt.value;
          if (!identifyRecipientFromMessage(message)) {
            message = `@${dispatcher.admin.name} ${message}`;
          }

          dispatcher.submitMessage({
            sender: user.name,
            message,
          });

          userPrompt.value = "";
        });
      }

      const dialogScreen = new DialogScreen();
      const dispatcher = new MessageDispatcher(dialogScreen);
      await setUpInitialAgents(dispatcher);
      setUpEventHandlers(dispatcher);
      dispatcher.run();
    })();
  </script>
</html>
