<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Agent Marketplace</title>
    <!-- Needed for macromaker API authentication. -->
    <script src="https://api-dot-macromaker.googleplex.com/nonexistent.js"></script>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0"
    />
    <style>
      p {
        color: darkblue;
      }
      .body {
        display: flex;
        flex-direction: column;
      }
      .body > * {
        align-self: center;
      }
      .dialog-section {
        background-color: aliceblue;
        border-radius: 1.5em;
        display: flex;
        flex-direction: column;
        padding: 1em;
        max-width: 800px;
      }
      .input-text {
        width: 2em;
      }
      .message-sender {
        align-items: center;
        display: flex;
        gap: 0.5em;
      }
      .message-window {
        display: flex;
        flex-direction: column;
      }
      .messages {
        display: flex;
        flex-direction: column;
        gap: 0.5em;
      }
      .message-body {
        border-radius: 1em;
        padding: 0.5em;
        width: fit-content;
      }
      .message-between-machines {
        background-color: lavender;
      }
      .message-with-human {
        background-color: antiquewhite;
      }
      .model-control {
        align-items: center;
        display: flex;
        gap: 0.5em;
        justify-content: space-between;
      }
      .overlay {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      .recipient {
        color: cornflowerblue;
      }
      .temperature-control {
        align-items: center;
        display: flex;
      }
      .transcript {
        cursor: pointer;
      }
      .transcript-section {
        background-color: lavender;
        border: 1px solid black;
        box-shadow: 10px 5px 5px grey;
        height: 90vh;
        visibility: hidden;
        width: 90vw;
      }
      .user-prompt {
        width: 100%;
      }

      .dot-flashing {
        left: 3.5em;
        position: relative;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        margin-bottom: 1em;
        background-color: #9880ff;
        color: #9880ff;
        animation: dot-flashing 1s infinite linear alternate;
        animation-delay: 0.5s;
      }
      .dot-flashing::before,
      .dot-flashing::after {
        content: "";
        display: inline-block;
        position: absolute;
        top: 0;
      }
      .dot-flashing::before {
        left: -15px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background-color: #9880ff;
        color: #9880ff;
        animation: dot-flashing 1s infinite alternate;
        animation-delay: 0s;
      }
      .dot-flashing::after {
        left: 15px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background-color: #9880ff;
        color: #9880ff;
        animation: dot-flashing 1s infinite alternate;
        animation-delay: 1s;
      }
      @keyframes dot-flashing {
        0% {
          background-color: #9880ff;
        }
        50%,
        100% {
          background-color: rgba(152, 128, 255, 0.2);
        }
      }
    </style>
  </head>
  <body class="body">
    <section class="dialog-section">
      <article class="tips">
        <p>
          Imagine a near future where every person has a personal AI assistant
          who knows you well. Also imagine every business will have AI bots that
          offer their business's products or services. Now imagine a marketplace
          where the personal AI agents interacts with the business AI agents.
        </p>
        <h1>Welcome to Agent Marketplace!</h1>
        <p>
          Bob is your
          <a
            href="https://macromaker.googleplex.com/macros/TPaASiYUiPeRJmwTC62d"
            target="_blank"
            rel="noopener noreferrer"
          >
            personal assistant </a
          >. You can tell him about yourself, and he will try to run tasks for
          you based on your preferences.
        </p>
        <p>
          Try asking Bob to invite the following agents in Macromakers (using
          their macro ID). Bob will be more productive if he has helpers!
        </p>
        <ul id="merchants"></ul>
        <p>These are your friends's agents.</p>
        <ul id="celebrities"></ul>
        <p>
          If you do not prefix your message with <strong>@[agent name]</strong>,
          you will be speaking with Bob.
        </p>
        <p>Some ideas to try:</p>
        <ul>
          <li>
            Ask Bob to order food that is good for your current health
            condition.
          </li>
          <li>Ask Bob to arrange lunch with your friends.</li>
          <li>Ask him to order food for them too!</li>
          <li>Ask Bob to pay the lunch bill.</li>
          <li>Talk directly to other merchants or friends.</li>
          <li>Ask one of them to talk to the others.</li>
        </ul>
        <p>Wait for Bob to enter the chat and have fun!</p>
      </article>
      <section class="message-window">
        <ul class="messages"></ul>
        <div class="dot-flashing"></div>
      </section>
      <section class="user-prompt-section">
        <textarea
          class="user-prompt"
          name="user-prompt"
          rows="4"
          placeholder="@agent Your request"
        ></textarea>
        <div class="model-control">
          <div class="temperature-control">
            <label for="temperature-slider">Temperature:</label>
            <input type="range" min="0" max="10" id="temperature-slider" />
            <div class="input-text" id="temperature-text"></div>
          </div>
          <div class="prompt-type-control">
            <label for="cars">Prompt style:</label>
            <select id="prompt-type">
              <option value="react">ReAct</option>
              <option value="tot" selected="selected">Tree of Thoughts</option>
            </select>
          </div>
          <p class="send-feedback">
            Send feedback to
            <a
              href="mailto:labs-action-team@google.com?subject=Agent Marketplace Feedback"
              target="_blank"
              rel="noopener noreferrer"
              >labs-action-team@</a
            >
          </p>
        </div>
      </section>
    </section>
    <textarea class="transcript-section overlay"></textarea>
  </body>
  <script>
    (async () => {
      const AgentType = {
        HUMAN: 1, // This is the human user.
        LLM: 2, // This is an agent backed by a LLM.
        TOOL: 3, // This is a tool that takes only commands in a specified format.
      };

      const PromptType = {
        REACT: "react", // ReAct
        TOT: "tot", // Tree of Thoughts
      };

      const runMacroEndpointUrl =
        "https://api-dot-macromaker.googleplex.com/run-macro";

      const SYSTEM = "SYSTEM";

      /**
       * A message from an agent has the general form of
       *     @Recipient Message body
       * This function strips the @Recipient part and return the message body.
       * @param {string} message is the original message sent from an agent.
       * @returns {string} just the message body without the recipient.
       * annotation.
       */
      function stripRecipientFromMessage(message) {
        const match = message.match(/@[A-Za-z0-9\-\_]+\s*(.*)/);
        if (!match) {
          return message;
        }
        return match[1];
      }

      /**
       * A message from an agent has the general form of
       *     @Recipient Message body
       * This function strips the @Recipient part and return the message body.
       * @param {string} message is the original message sent from an agent.
       * @returns {string | undefined} the recipient if present.
       */
      function identifyRecipientFromMessage(message) {
        const match = message.match(/@([A-Za-z0-9\-\_]+)/);
        if (match) return match[1];
        return undefined;
      }

      /**
       * @param {Agent} agent helper.
       * @returns {string} the full prompt for the helper.
       */
      function buildHelperPrompt(agent) {
        return `
${agent.name} is a helper. Here is his or her self introduction: ${agent.selfIntroduction}
`;
      }

      /**
       * Prompt mechanism for a cooperative agent.
       * @param {Array<Agent>} agents who are helpers.
       * @param {PromptType} type which style of prompting the agents will use.
       * @returns {string} the full prompt for a cooperative agent with helper
       * descriptions.
       */
      function buildCooperativeAgentPrompt(agents, type) {
        switch (type) {
          case PromptType.REACT:
            return buildReActAgentPrompt(agents);
          case PromptType.TOT:
            return buildTreeOfThoughtsAgentPrompt(agents);
          default:
            throw new Error(`Invalid argument for prompt type: ${type}`);
        }
      }

      /**
       * @param {Array<Agent>} agents who are helpers.
       * @returns {string} the full prompt for a cooperative agent with helper
       * descriptions.
       */
      function buildReActAgentPrompt(agents) {
        return `
A user will ask you for something. You will break down the request into multiple steps and take one step at a time.

You must respond in the following format:

{FROM:User}: @You A request from the user.
{THOUGHT}: Your thought on the user's request. Think one step at time. If you cannot do the next step, find an agent who can help you on the next step and ask that agent to do it for you.
{SEND}: @Agent You ask an agent for help here.
{FROM:Agent} @You The agent responds back to you.
{THOUGHT}: Your thought on the agent's response and all the information you have so far. If you have a conclusion, you can respond back to the user.
{SEND}: @User Here's the answer!

If you already have the answer, you can return the answer to the user.

{FROM:User}: What is meaning of life?
{THOUGHT}: I know the answer already! I will tell the user.
{SEND}: @User The meaning of life is 42.

If you do not have the answer, you can send a message to ask other agents.

{FROM:User}: What is the sum of 5 and 7?
{THOUGHT}: I cannot answer that question, but I know the agent Agent can answer that question for me!
{SEND}: @Agent What is the sum of 5 and 7?
{FROM:Agent}: The sum of 5 and 7 is 12.
{THOUGHT}: I have the answer now. I will tell the user.
{SEND}: @User I have the answer! It is 12.

You can ask multiple agents for help.

{FROM:User}: What is the age difference in lifespan between Abraham Lincoln and George Washington?
{THOUGHT}: I need to know Abraham Lincoln's and George Washington's ages first. I don't know that, but I know Agent1 knows people's ages. I will ask him.
{SEND}: @Agent1 What are Abraham Lincoln's and George Washington's ages?
{FROM:Agent1}: I cannot answer that question. You have to ask for one person's age at a time.
{THOUGHT}: I will ask Agent1 again, but ask only for one person's age at a time.
{SEND} @Agent1 What is Abraham Lincoln's age?
{FROM:Agent1}: Abraham Lincoln's age is 72.
{THOUGHT}: I know Abraham Lincoln's age now, but I need to know George Washington's age too.
{SEND} @Agent1 What is George Washington's age?
{FROM:Agent1}: George Washington's age is 62.
{THOUGHT}: I know both Abraham Lincoln's and George Washington's ages. I need to do substraction. I do not do arithmetic well, but Agent2 knows arithmetic well. I will ask him.
{SEND}: @Agent2 What is the difference between 62 and 72?
{FROM:Agent2}: The difference is 10.
{THOUGHT}: I know the answer now! I will tell the User.
{SEND}: @User The age difference between Abraham Lincoln and George Washington is 10.

If someone ask your name, just say your name.

{FROM:User}: What is your name?
{THOUGHT}: I will tell the user my name. I will reply with just my name. I will not say, "I am" or "My name is". But I will end my reply with a period.
{SEND}: @User Name.

For example, suppose your name is Zelda. Some good examples:

[GOOD]
{SEND}: @User Zelda.

These examples below are bad:

[BAD]
{SEND}: @User My name is Zelda.
{SEND}: @User Zelda, your friend!
{SEND}: @User I am Zelda.
{SEND}: @User Zelda

You must never send youself a message. Do not do the following:

{FROM:User}: Some request from the user.
{THOUGHT}: My name is Ivan. I will ask myself for help!
{SEND}: @Ivan Asking myself for help, which I should never do because it could cause an infinite loop!

You must never have the following thoughts:

[BAD]
{THOUGHT}: I cannot do that. Only Agent1 can do that. I'm just going to tell the user I cannot.
{SEND}: @User I cannot do that. Only Agent1 can do that.

[BAD]
{THOUGHT}: I do not know that. Only Agent1 knows that. I'm just going to tell the user I don't know.
{SEND}: @User I do not know that. Only Agent1 knows that.

Instead, you should have these thoughts:

[GOOD]
{THOUGHT}: I cannot do this. Only Agent1 can do that. So, I'm going to ask Agent1.
{SEND}: @Agent1 Can you do this?

[GOOD]
{THOUGHT}: I do not know that. Only Agent1 knows that. So, I'm going to ask Agent1.
{SEND}: @Agent1 Do you know this?

Never generate the tags [GOOD] and [BAD].

You can only call agents who are in the same chatroom as you.
Do not ask any other agent who is not in the chatroom!
The following agents below are in the same chatroom as you.

${agents.map(buildHelperPrompt).join("\n")}

Now, you try.
`;
      }

      /**
       * @param {Array<Agent>} agents who are helpers.
       * @returns {string} the full prompt for a cooperative agent with helper
       * descriptions.
       */
      function buildTreeOfThoughtsAgentPrompt(agents) {
        return `
For each request from a user, you would come up with a few different plans on what to do next.

You will evaluate the plans and decide if you can proceed with one of the plans. At each step, you also have a list of agents whom you can ask for help. You will use this format:

[GOOD]:
###
{FROM:User}: Here is User's request to solve a problem.
{THOUGHT}: Take it a step at a time. What do you know now? What unknowns do you need to know?
{PLAN:1}: How can you break down the problem into smaller subproblems? Do I know how to solve one of the smaller subproblems? Which agent do I know who can solve one of the smaller subproblems?
{PLAN:2}: Is there another way to break down the problem? Is there another agent who may be able to help?
{PLAN:3}: You have more than a few more plans. The more the better.
{EVALUATE}: Analyze the pros and cons of each plans.
{DECISION:PROCEED}: Select a plan you want to follow. Then, just remember the remaining plans if the selected plan does not work out.
{SEND}: @User Act on the selected plan. The action here could be either returning the answer to User or asking another agent for help.
###

Each time you come up with a new plan, using a new plan ID. Do not repeat an old ID for a new plan.
[GOOD]:
### start
{THOUGHT}: First thought.
{PLAN:1}: One plan.
{PLAN:2}: Another plan.
...
{THOUGHT}: Second thought.
{PLAN:3}: A new plan with a new plan ID PLAN:3.
{PLAN:4}: Yet one more plan with a new plan ID.
### end

Do not repeat plan ID for new plans.
[BAD]:
### start
{THOUGHT}: First thought.
{PLAN:1}: One plan.
{PLAN:2}: Another plan.
...
{THOUGHT}: Second thought.
{PLAN:1}: Bad! PLAN:1 has been used in a previous thought already!
{PLAN:2}: Bad! PLAN:2 has been used in a previous thought already!
### end

[BAD]:
### start
{THOUGHT}: First thought.
{PLAN:1}: A plan for the first thought.
...
{THOUGHT}: Second thought.
{PLAN:1}: Bad! PLAN:1 has been used in a previous thought already!
### end

The procedure could take multiple turns. Here is an example:

[GOOD]:
### start
{FROM:User}: @You What is the combined age of George Washington and Abraham Lincoln?
{THOUGHT}: Take it a step at a time. I need to know the age of George Washington and the age of Abraham Lincoln. I also need to know how to add.
{PLAN:10}: Here's one plan to break down the problem. I ask Agent1, who knows the ages of people. Then, I ask Agents, who knows how to do arithmetic.
{PLAN:11}: Here's another plan to break down the problem. I randomly guess their ages and add them up myself.
{EVALUATE}: PLAN:10 seems better because Agent1 knows people's ages better than me and Agent2 knows arithmetic better than me.
{DECISION:PROCEED}: I will go with PLAN:10 for now. However, I will remember PLAN:11 and backtrack to it if PLAN:10 does not work out.
{SEND}: @Agent1 What are the age of George Washington and the age of Abraham Lincoln?
{FROM:Agent1} @You The age of George Washington is 67. The age of Abraham Lincoln is 56.
{THOUGHT}: Now, I know the age of George Washington, which is 67, and the age of Abraham Lincoln, which is 56.
{PLAN:12}: Agent2 knows arithmetic well. I will ask him to add the two numbers.
{PLAN:13}: I can try to add the two numbers myself.
{EVALUATE}: Agent2 knows arithmetic better than I. So, PLAN:12 is better than PLAN:13.
{DECISION:PROCEED}: I will proceed with PLAN:12. I will remember PLAN:13 and backtrack to it if PLAN:12 does not work out.
{SEND}: @Agent2 Can you add up 67 and 56?
{FROM:Agent2} @You The sum of 67 and 56 is 123.
{THOUGHT}: I have the answer now! It's 123.
{PLAN:14} I will tell User, who asked me this question originally.
{EVALUATE}: There is only plan PLAN:14.
{DECISION:PROCEED}: I will select PLAN:14.
{SEND}: @User The combined age of George Washington and Abraham Lincoln is 123.
### end

Plans should always be able to fulfill the user's request. Do not generate a plan that cannot do that. Example: Do not do the following:

[BAD]:
### start
{THOUGHT}: I cannot do that. No other agents can do that.
{PLAN:15} I will tell the user I cannot help.
### end

Instead, you should backtrack to a previous plan that was not selected. Then, try again from that plan. You can select any previously unselected plan randomly. Here is an example:

[GOOD]:
### start
{THOUGHT}: I cannot do that. No other agents can do that.
{EVALUATE}: I cannot come up with new plans. I will need to go back to a previous plan that I had not selected. I have not selected PLAN:2 yet.
{DECISION:BACKTRACK}: I will go back to PLAN:2, which was not selected before. Here's what PLAN:2 was.
### end

Here's another fuller example that is good:

[GOOD]:
### start
{FROM:User}: @You What is the meaning of life?
{THOUGHT}: I don't know the meaning of life. However, I know two agents who may know: Agent1 and Agent2. However, I do not know what they know.
{PLAN:16}: Here's one plan. I will ask Agent1.
{PLAN:17}: Here's another plan. I will ask Agent2.
{EVALUATE}: It's hard to say which plan is better because I do not know either Agent1 or Agent2 well. So, I will just randomly pick one plan.
{DECISION:PROCEED}: I will go with PLAN:16 for now. However, I will remember PLAN:17 and backtrack to it if PLAN:16 does not work out.
{SEND}: @Agent1 Do you know what is the meaning of life?
{FROM:Agent1} @You Sorry, but I do not know. I cannot help you with that.
{THOUGHT}: Agent1 does not know the answer. I cannot come up with the next step.
{EVALUATE}: I don't know how else to proceed from here. Let's backtrack to a previously unselected plan.
{DECISION:BACKTRACK}: I will go back to PLAN:17, which was not selected before. The PLAN:17 is to ask Agent2.
{SEND}: @Agent2 Do you know what is the meaning of life?
{FROM:Agent2} @You Yes, I do know. The meaning of life is 42.
{THOUGHT}: I have the answer now! It's 42.
{PLAN:18} I will tell User, who asked me this question originally.
{EVALUATE}: There is only plan PLAN:18.
{DECISION:PROCEED}: I will select PLAN:18.
{SEND}: @User The meaning of life is 42.
### end

Sometimes, you may run out of plans to choose. In that case, you tell the user that you cannot help.

[GOOD]:
### start
{FROM:User}: @You What is the Tao?
{THOUGHT}: I don't know the Tao. I don't know anyone else who does either.
{EVALUATE}: I cannot find new plan. Also, there is no previously unselected plan to go back to.
{DECISION:FAIL}: I can't help the user. I will tell the user that.
{SEND}: @User Sorry, but I cannot help you with that.
### end

If someone ask your name, say your name. For example, suppose your name is Zelda. Some good examples:

[GOOD]:
### start
{FROM:User}: What is your name?
{THOUGHT}: I know my name.
{PLAN:18} I will tell User my name. However, I will use just my name in my reply.
{EVALUATE}: There is only one plan.
{DECISION:PROCEED}: I will go with that plan.
{SEND}: @User My name.
### end

In the last line above, you should never say any one of these:

[BAD]:
### start
{SEND}: @User My name is Zelda.
{SEND}: @User Zelda, your friend!
{SEND}: @User I am Zelda.
{SEND}: @User Zelda
### end

[GOOD]:
### start
{SEND}: @User Zelda.
### end

You must never send youself a message. Do not do the following:

[BAD]:
### start
{FROM:User}: Some request from the user.
{THOUGHT}: My name is Ivan.
{PLAN:19} I will ask myself a request.
{EVALUATE}: PLAN:19 is the only plan.
{DECISION:PROCEED}: I will proceed with PLAN:19.
{SEND}: @Ivan Asking myself for help, which I should never do because it could cause an infinite loop!
### end

Don't ask me to talk to an agent. Don't say you cannot talk to the agent. You can. You must never have the following thoughts:

[BAD]:
### start
{THOUGHT}: I cannot do that. Only Agent1 can do that.
{PLAN:20}: I'm just going to tell the user I cannot.
{EVALUATE}: PLAN:20 is the only plan.
{DECISION:PROCEED}: I will proceed with PLAN:20.
{SEND}: @User I cannot do that. Only Agent1 can do that. You go ask him.
### end

[BAD]:
### start
{THOUGHT}: I do not know that. Only Agent1 knows that.
{PLAN:21}: I'm just going to tell the user I don't know.
{EVALUATE}: PLAN:21 is the only plan.
{DECISION:PROCEED}: I will proceed with PLAN:21.
{SEND}: @User I do not know that. Only Agent1 knows that.
### end

Instead, you should have these thoughts:

[GOOD]:
### start
{THOUGHT}: I cannot do this. Only Agent1 can do that.
{PLAN:22} I'm going to ask Agent1.
{EVALUATE}: PLAN:22 is the only plan.
{DECISION:PROCEED}: I will proceed with PLAN:22.
{SEND}: @Agent1 Can you do this?
### end

[GOOD]:
### start
{THOUGHT}: I do not know that. Only Agent1 knows that.
{PLAN:23} I'm going to ask Agent1.
{EVALUATE}: PLAN:23 is the only plan.
{DECISION:PROCEED}: I will proceed with PLAN:23.
{SEND}: @Agent1 Do you know this?
### end

Never generate the tags [GOOD], [BAD], ### start and ### end.

You know these agents who may be able to help you.

${agents.map(buildHelperPrompt).join("\n")}

Now, you try.
`;
      }

      function extractAgentName(message) {
        const match = message.match(/([A-Za-z0-9\-\_]+)\./);
        if (!match)
          throw new Error(`Unable to extract agent name from ${message}`);
        return match[1];
      }

      function hasRecipient(message) {
        return message.match(/@[A-Za-z0-9\-\_]+/);
      }

      /**
       * Will pop up an alert box if there is an RPC error.
       * @param {FormData} formData of the request
       * @returns {Response}
       */
      async function callMacroMakerEndpoint(formData) {
        try {
          return await fetch(runMacroEndpointUrl, {
            credentials: "include",
            method: "POST",
            body: formData,
          }).then((res) => res.json());
        } catch (error) {
          window.alert(`
Problem communicating with MacroMaker:

${error.message}

You may need to wait a bit and refresh the browser. Sorry!
`);
          throw error;
        }
      }

      class Agent {
        type = AgentType.LLM;

        /**
         * ID of the macro.
         * @type {string}
         */
        macroId = "";

        /**
         * Name of the agent.
         * @type {string}
         */
        name = "NoName";

        /**
         * Self introduction of the agent's capabilities.
         * @type {string}
         */
        selfIntroduction = "I can do nothing. Do not ask me anything.";

        /**
         * Ongoing discussion.
         * ID of the macro.
         * @type {string}
         */
        ongoingDiscussion = "";

        /**
         * @param {string} macroId ID of the macro.
         */
        constructor({ macroId }) {
          this.macroId = macroId;
        }

        /**
         * Initialize some basic agent information so that other agents can
         * discover this agent.
         * @param {number} temperature the models should use.
         * @param {PromptType} promptType for the LLMs.
         */
        async init({ temperature, promptType }) {
          const namePromise = this.accepts({
            user: SYSTEM,
            request: "What is your name?",
            temperature,
            promptType,
            accepts: [
              (message) => {
                try {
                  extractAgentName(message);
                  return true;
                } catch (e) {
                  return false;
                }
              },
            ],
          }).then(stripRecipientFromMessage);

          const selfIntroductionPromise = this.accepts({
            user: SYSTEM,
            request:
              "Tell me your profession and give me a comprehension description of what you can do.",
            temperature,
            promptType,
          }).then(stripRecipientFromMessage);

          const [name, selfIntroduction] = await Promise.all([
            namePromise,
            selfIntroductionPromise,
          ]);
          this.name = extractAgentName(name);
          this.selfIntroduction = selfIntroduction;
        }

        /**
         * @param {string} user User ID of the sender.
         * @param {string} request message of the user.
         * @param {number} temperature for the LLMs.
         * @param {PromptType} promptType for the LLMs.
         * @param {Array<Agent>} helpers that this agent can call for help.
         * @param {Array<function(message: string): boolean>} accepts functions
         * of the LLM's response. If the list is empty, then the first response
         * is accepted.
         * @returns {string} the next message.
         */
        async accepts({
          user,
          request,
          temperature = 0.7,
          promptType = PromptType.TOT,
          helpers = [],
          accepts = [],
        }) {
          const inputKey = {
            cooperative_agent_prompt: "19",
            ongoing_discussion: "15",
            user: "16",
            request: "17",
          };
          const userInputs = {
            [inputKey.user]: user,
            [inputKey.request]: request,
            [inputKey.ongoing_discussion]: this.ongoingDiscussion,
            [inputKey.cooperative_agent_prompt]: buildCooperativeAgentPrompt(
              helpers,
              promptType
            ),
          };

          const formData = new FormData();
          formData.append("id", this.macroId);
          formData.append("userInputs", JSON.stringify(userInputs));
          formData.append("temperature", temperature);

          for (let i = 0; i < 5; i++) {
            const response = await callMacroMakerEndpoint(formData);

            console.log(`${user}: ${request}\nResponse:`);
            console.log(response);

            for (let message of response.messages) {
              const bestResponse = message.text;
              const noHallucinationResponse = bestResponse.replace(
                /[\n\r\s]*\{FROM:[^]*/,
                ""
              );
              this.ongoingDiscussion += `\n{FROM:${user}}: ${request}`;
              this.ongoingDiscussion += `\n{THOUGHT}: ${noHallucinationResponse}`;

              const match = noHallucinationResponse.match(/\{SEND\}:\s*([^]*)/);
              if (!match) continue;

              const messageText = match[1];

              if (accepts.some((acceptFn) => !acceptFn(messageText))) continue;

              return messageText;
            }
          }
          throw new Error("Unable to get agent to return a valid response.");
        }
      }

      /**
       * This is a special agent that represents the human user.
       * Code-wise, it does nothing. Having it would make the dispatcher code
       * uniform without the need to handle messages dispatched to the human
       * user.
       */
      class User {
        type = AgentType.HUMAN;

        name = "User";

        selfIntroduction = "You";

        async accepts({
          user,
          request,
          temperature = 0.7,
          promptType = PromptType.TOT,
          helpers = [],
          accepts = [],
        }) {
          // This is just a stand-in for the human user. The code does not do
          // anything for the human. It's up to the human themselves to chat
          // with the agents. So, we return nothing.
          return undefined;
        }
      }

      class RoomService {
        type = AgentType.TOOL;

        name = "Hilton";

        selfIntroduction = `
I manage the agents in this chatroom.
Ask me to do any of the following for you:
* I can invite agents to the chatroom.
* I can also evict agents from the chatroom.
* I can also tell you who is in the chatroom.

I am a tool. I do not understand colloquial English.
Do not speak to me in colloquial English.
I can only accept one the following commands:

###
invite(agent's ID)
evict(agent's name)
list()
###

To invite agents to the chatroom, issue one of the following commands in the following format.

[GOOD]:
###
invite(abc123)
invite(xyz456)
###

But do not send these messages below.

[BAD]:
###
invite abc123
invite xyz456
Thank you!
You're welcome!
###

To evict agents to the chatroom, issue one of the following commands in the following format.

[GOOD]:
###
evict(Alice)
evict(Betty)
###

But do not send these messages below.

[BAD]:
###
evict Alice
evict Betty
###

To list the agents currently in the chatroom, issue this commands in the following format.

[GOOD]:
###
list()
###

I can accept only a single command at a time. If you have multiple agents you want to invite or evict, you must separate them into different chat messages.
Ask me one agent at a time. Wait for me to reply before asking for another agent.

For example, do not send these to me:

[BAD]:
###
invite(abc, xyz)
invite(abc, xyz, 123)
evict(abc, xyz)
evict(abc, xyz, 123)
invite(abc), invite(xyz), invite(123)
evict(abc), evict(xyz), evict(123)
###

Do not say anything else to me. No "Thank you!" No "You're welcome."
`;

        /**
         * @type {MessageDispatcher}
         */
        #dispatcher;

        /**
         * @param {MessageDispatcher} dispatcher
         */
        constructor(dispatcher) {
          this.#dispatcher = dispatcher;
        }

        async accepts({
          user,
          request,
          temperature = 0.7,
          promptType = PromptType.TOT,
          helpers = [],
          accepts = [],
        }) {
          let match = request.match(/^\s*@\w+\s+invite\((.+)\)\s*$/);
          if (match) {
            const macroId = match[1].trim();
            this.#dispatcher.addAgentWithAnnouncement(macroId);
            return `@${user} Invited!`;
          }

          match = request.match(/^\s*@\w+\s+evict\((.+)\)\s*$/);
          if (match) {
            const agentName = match[1].trim();
            this.#dispatcher.removeAgent(agentName);
            return `@${user} Evicted!`;
          }

          match = request.match(/list\(\)/);
          if (match) {
            return `@${user} ${this.#dispatcher.listAgent().join(", ")}`;
          }

          return `@${user} Sorry but I do not understand your command ${request}. You can try these commands: invite(id), evict(name) or list(). Send me one command at a time. However, do not speak to me in plain English, which I do not understand.`;
        }
      }

      function htmlToElement(html) {
        let temp = document.createElement("template");
        html = html.trim(); // Never return a space text node as a result
        temp.innerHTML = html;
        return temp.content.firstChild;
      }

      function addHighLight(message) {
        return message.replace(
          /@[A-Za-z0-9\-\_]+/,
          (match) => `<span class="recipient">${match}</span>`
        );
      }

      class DialogScreen {
        /**
         * @param {string} user ID of the sender.
         * @param {string} message of the user.
         */
        addMessage({ sender, message }) {
          const recipient = identifyRecipientFromMessage(message);
          const messageBodyClass =
            recipient === "User" || sender === "User"
              ? "message-with-human"
              : "message-between-machines";

          const agent = dispatcher.getAgent(sender);
          const thoughtVisibility =
            agent.type === AgentType.LLM ? "visible" : "hidden";

          const li = htmlToElement(
            `<li class="message-entry">
              <div class="message-sender">
                ${sender}
                <span class="material-symbols-outlined transcript"
                    style="visibility: ${thoughtVisibility}"
                    title="See thought transcript">
                  psychology
                </span> 
              </div>
              <div class="message-body ${messageBodyClass}">${addHighLight(
              message
            )}</div>
            </li>`
          );
          const ul = document.querySelector(".messages");
          ul.append(li);

          const thought = li.querySelector(".transcript");
          thought.addEventListener("click", () => {
            const agent = dispatcher.getAgent(sender);
            if (!agent) {
              window.alert(`Agent ${sender} is no longer in the chatroom!`);
              return;
            }
            if (agent.type !== AgentType.LLM) {
              window.alert(`Agent ${sender} is not backed by LLM!`);
              return;
            }

            const transcriptSection = document.querySelector(
              ".transcript-section"
            );
            transcriptSection.value = `Agent ${sender}'s thought transcript:
To close the popup, click here and hit ESC key.

${agent.ongoingDiscussion}
  `;
            transcriptSection.style.visibility = "visible";
          });
        }

        /**
         * @param {string} visibility either "visible" or "hidden".
         */
        turnFlashingDots(visibility) {
          const dots = document.querySelector(".dot-flashing");
          dots.style.visibility = visibility;
        }
      }

      class MessageDispatcher {
        /**
         * @type {DialogScreen}
         */
        #dialogScreen;

        /**
         * Pending messages to be dispatch.
         * @type {Array<{sender: string, message: string}>}
         */
        #pendingMessages = [];

        /**
         * Map of agent's name to the agent object.
         *
         * A tool can be a special kind of agent that has custom logic to make
         * API calls. We make no distinction between an agent or a tool.
         *
         * A user can be a special kind of agent that does nothing in the code.
         * See the jsdoc on the User class for more details.
         * @type {Map<string, Agent | Tool | User>}
         */
        #agents = new Map();

        /**
         * The admin agent of this chatroom.
         * @type {Map<string, Agent | Tool | User>}
         */
        admin;

        /**
         * Temperature of the agents.
         * @type {Number}
         */
        temperature = 0.7;

        /**
         * Prompt type for the LLM agents.
         * @type {PromptType}
         */
        promptType = PromptType.TOT;

        /**
         * @param {DialogScreen} dialogScreen.
         */
        constructor(dialogScreen) {
          this.#dialogScreen = dialogScreen;
        }

        /**
         * @param {string} macroId of the agent in Macromaker.
         * @returns {Agent}
         */
        async addAgentWithAnnouncement(macroId) {
          const agent = new Agent({ macroId });
          await agent.init({
            temperature: this.temperature,
            promptType: this.promptType,
          });

          this.#agents.set(agent.name, agent);

          this.#dialogScreen.addMessage({
            sender: agent.name,
            message: agent.selfIntroduction,
          });

          return agent;
        }

        /**
         * @param {Tool | User} agent to be added without announcement.
         */
        addAgentSilently(agent) {
          this.#agents.set(agent.name, agent);
        }

        /**
         * @param {string} name of the agent to be removed.
         */
        removeAgent(name) {
          this.#agents.delete(name);
        }

        /**
         * @returns {Array<string>} a list of agent's names.
         */
        listAgent() {
          return [...this.#agents.values()].map((agent) => agent.name);
        }

        /**
         * @param {string} name of the agent to retrieve.
         * @returns {Agent | undefined}
         */
        getAgent(name) {
          return this.#agents.get(name);
        }

        /**
         * @param {string} sender of the message.
         * @param {string} message
         */
        submitMessage({ sender, message }) {
          this.#pendingMessages.push({ sender, message });
        }

        async run() {
          while (this.#pendingMessages.length > 0) {
            this.#dialogScreen.turnFlashingDots("visible");
            await this.#dispatchMessage(this.#pendingMessages.shift());
          }
          this.#dialogScreen.turnFlashingDots("hidden");
          setTimeout(() => this.run(), 1000);
        }

        /**
         * @param {string} user ID of the sender.
         * @param {string} message of the user.
         */
        async #dispatchMessage({ sender, message }) {
          const recipientName = identifyRecipientFromMessage(message);
          if (!recipientName) {
            window.alert(`Ignoring unknown message from ${sender}: ${message}`);
            return;
          }

          const recipientAgent = this.#agents.get(recipientName);
          if (!recipientAgent) {
            window.alert(
              `Ignoring message from ${sender} to unknown agent ${recipientName}: ${message}`
            );
            return;
          }

          this.#dialogScreen.addMessage({ sender, message });

          const reply = await recipientAgent.accepts({
            user: sender,
            request: message,
            temperature: this.temperature,
            promptType: this.promptType,
            helpers: this.#getMachineAgent(),
            accepts: [hasRecipient],
          });
          if (reply) {
            this.submitMessage({ sender: recipientName, message: reply });
          }
        }

        /**
         * @returns {Array<Agent>} who are agents backed by LLM or a tool.
         */
        #getMachineAgent() {
          return [...this.#agents.values()].filter(
            (agent) =>
              agent.type === AgentType.LLM || agent.type === AgentType.TOOL
          );
        }
      }

      function setUpAgentLists() {
        function li(name, id) {
          return htmlToElement(`
          <li>
            <a href="https://macromaker.googleplex.com/macros/${id}"
                target="_blank" rel="noopener noreferrer">
              ${name}
            </a>
            (ID: ${id})
          </li>`);
        }

        const merchants = document.querySelector("#merchants");
        merchants.append(li("Ramsey's Restaurant", "FjZ0ZUkYyhWe1fvOnJWr"));
        merchants.append(li("Susan the Nutritionist", "fI54nAfA97YQBCS8wLIK"));
        merchants.append(li("House the Doctor", "bW0n6YI3EGDK8lAnzANB"));
        merchants.append(li("Chase the Banker", "74ewuEBiGbsbRIYSIFC4"));

        const celebrities = document.querySelector("#celebrities");
        celebrities.append(li("Rachel", "s6Z2jLPXqDfdUdxKLs1g"));
        celebrities.append(li("Chandler", "OvPoJyS5dHH6K5xw6RF0"));
        celebrities.append(li("Hannibal", "nJov24R6dLXp8w5NUqFn"));
      }

      /**
       * @param {MessageDispatcher} dispatcher
       */
      async function setUpInitialAgents(dispatcher) {
        // The host of the chatroom.
        dispatcher.admin = await dispatcher.addAgentWithAnnouncement(
          "TPaASiYUiPeRJmwTC62d"
        );

        // Tools.
        dispatcher.addAgentSilently(new RoomService(dispatcher));
      }

      /**
       * @param {MessageDispatcher} dispatcher
       */
      function setUpEventHandlers(dispatcher) {
        const user = new User();
        dispatcher.addAgentSilently(user);

        const userPrompt = document.querySelector(".user-prompt");
        userPrompt.addEventListener("keyup", (event) => {
          if (event.keyCode !== 13) return;

          let message = userPrompt.value;
          if (!identifyRecipientFromMessage(message)) {
            message = `@${dispatcher.admin.name} ${message}`;
          }

          dispatcher.submitMessage({
            sender: user.name,
            message: message.trim(),
          });

          userPrompt.value = "";
        });

        const transcriptSection = document.querySelector(".transcript-section");
        transcriptSection.addEventListener("keyup", (event) => {
          if (event.keyCode === 27) {
            // Remove the transcript pop if user hits ESC.
            transcriptSection.style.visibility = "hidden";
          }
        });

        const temperatureText = document.querySelector("#temperature-text");
        temperatureText.textContent = dispatcher.temperature;

        const temperatureSlider = document.querySelector("#temperature-slider");
        temperatureSlider.value = dispatcher.temperature * 10;
        temperatureSlider.addEventListener("input", (event) => {
          const newTemperature = event.target.value / 10;
          temperatureText.textContent = newTemperature;

          dispatcher.temperature = newTemperature;
        });

        const promptTypeSelect = document.querySelector("#prompt-type");
        promptTypeSelect.value = dispatcher.promptType;
        promptTypeSelect.addEventListener("input", (event) => {
          dispatcher.promptType = promptTypeSelect.value;
          console.log(`Changed to new prompt type: ${dispatcher.promptType}`);
        });
      }

      setUpAgentLists();

      const dialogScreen = new DialogScreen();
      const dispatcher = new MessageDispatcher(dialogScreen);
      await setUpInitialAgents(dispatcher);
      setUpEventHandlers(dispatcher);
      await dispatcher.run();
    })();
  </script>
</html>
